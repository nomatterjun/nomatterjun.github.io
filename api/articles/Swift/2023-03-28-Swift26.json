{"title":"26)🍎 Swift - Concurrency","uid":"d77fc5a0b46ee953e78fea8c5bdb21ac","slug":"Swift/2023-03-28-Swift26","date":"2023-03-27T15:00:00.000Z","updated":"2023-03-31T14:06:38.437Z","comments":true,"path":"api/articles/Swift/2023-03-28-Swift26.json","keywords":null,"cover":"https://i.imgur.com/3V3xo6Q.png","content":"<h1 id=\"Concurrency\"><a href=\"#Concurrency\" class=\"headerlink\" title=\"Concurrency\"></a>Concurrency</h1><p>WWDC21의 주요 주제는 Concurrency라고 생각합니다.</p>\n<p>21년에 처음 공개된 후 관련된 포스트도 많아졌고 서드파티 라이브러리에서도 대응 업데이트가 많이 이루어진 상황입니다.</p>\n<p>이제 슬슬 실무에 사용되는 모습들도 보이기 시작하는 것 같습니다.</p>\n<p>어렴풋이 “<code>async</code>와 <code>await</code>를 사용하는 문법이다.” 정도로만 알아두고 나중에 공부해야겠다 생각했지만 프로젝트에서 <code>callback</code> 지옥을 본 순간.. 학구열이 올라 한 번 학습해봤습니다.</p>\n<p>WWDC21의 세션들을 살펴보았더니 관련 세션만 거의 10개에 달하고 하나하나의 내용들도 꽉 찬 20~30분 정도를 이루고 있더군요..</p>\n<p>그래서 내용이 무지무지 많습니다.. 🫠</p>\n<h2 id=\"비동기-프로그래밍\"><a href=\"#비동기-프로그래밍\" class=\"headerlink\" title=\"비동기 프로그래밍\"></a>비동기 프로그래밍</h2><p><strong>비동기 코드</strong>는 <strong>“나중에 언젠가 호출되어 실행될 코드”</strong> 입니다.</p>\n<p>그 시기는 보장되지 않으며 순서 또한 보장되지 않을 때도 있습니다.</p>\n<p>Swift에서는 우리가 흔히 <strong>GCD</strong>라고 부르는 <code>DispatchQueue</code>를 통해 지원하는 개념이였죠.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">print(&quot;1&quot;)\nDispatchQueue.main.async &#123;\n  print(&quot;2&quot;)\n&#125;\nprint(&quot;3&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위 코드의 <code>print(&quot;2&quot;)</code> 구문은 비동기 코드입니다.</p>\n<p>따라서 순서와 호출 시기가 불확실합니다.</p>\n<p>바로 호출될수도 있고 아닐수도 있죠.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1 2 3</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1 3 2</p></blockquote>\n<p>그래서 위와 같이 <strong>실행마다 결과가 다를</strong>수도 있습니다.</p>\n<p>비동기코드는 <strong>1. 해당 라인에 도달되도 바로 실행되지 않고</strong>, <strong>2. 이후에 있는 코드의 실행을 Blocking하지도 않습</strong>니다.</p>\n<p>비동기 코드가 언제 실행되는지 모른다면, 비동기적으로 산출된 어떤 값을 언제 사용해야 할까요?</p>\n<p>다행히도 비동기 코드가 <strong>종료되는 시점</strong>은 우리가 알 수 있습니다.</p>\n<p><strong><code>@escaping</code> 클로저</strong>를 통해서요.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func foo() &#123;\n  print(&quot;1&quot;)\n  asyncFoo(completion: &#123; value in\n    print(value)\n  &#125;)\n  print(&quot;3&quot;)\n&#125;\n\nfunc asyncFoo(completion: @escaping (String) -&gt; Void) &#123;\n  DispatchQueue.main.async &#123;\n    let a &#x3D; &quot;2&quot;\n    completion(a)\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>asyncFoo</code> 메서드에서 <code>completion</code> 클로저는 <code>async</code> 함수가 종료되는 시점에 호출되어 콜러인 <code>foo</code> 메서드에 <code>String</code> 타입 파라미터 <code>value</code>를 제공합니다.</p>\n<p>이런 방식의 문법은 어떤 함수가 끝났을 때의 동작들의 묶음을 명시적으로 모아둘 수 있다는 장점이 있지만 <em>(장점인가..?)</em> <code>callback</code> 지옥과 코드 가독성이 떨어진다는 문제점을 가집니다.</p>\n<h3 id=\"GCD의-진짜-문제점\"><a href=\"#GCD의-진짜-문제점\" class=\"headerlink\" title=\"GCD의 진짜 문제점\"></a>GCD의 진짜 문제점</h3><p>코드의 가독성과 개발자에게 주는 불쾌한 경험도 중요하지만 GCD에는 더욱 크리티컬한 단점이 존재합니다.</p>\n<p>바로 <strong>CPU의 불필요한 추가 동작</strong>과 <strong>과도한 리소스의 사용</strong>을 유발할 수 있다는 점입니다.</p>\n<p>이게 무슨 말인지 살펴볼까요?</p>\n<p>DispatchQueue에 동작이 enqueue되면, 시스템은 해당 작업이 수행될 <strong>쓰레드를 불러오고 수행</strong>시킵니다.</p>\n<p>만약 무수히 많은 동작들이 enqueue되면, 시스템은 해당 동작들을 동시에 수행하기 위해 <strong>쓰레드를 계속해서 불러</strong>옵니다. <strong>CPU의 코어</strong>가 <strong>더 이상의 쓰레드 작업을 추가할 수 없을 때까지</strong>요.</p>\n<p><img src=\"https://i.imgur.com/wFvTBDv.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>코어가 2개인 환경에서 쓰레드를 추가적으로 불러오는 상황</p></blockquote>\n<p>하나의 코어가 여러개의 쓰레드를 가지고 있는 이유는 여러가지입니다.</p>\n<ol>\n<li>하나의 쓰레드가 Block되더라도 <strong>코어가 쉬지않고 다른 쓰레드의 작업</strong>을 할 수 있도록 하기 위해</li>\n<li>쓰레드간의 <strong>Race Condition을 해결</strong>하기 위해 (Semaphore 참고)</li>\n</ol>\n<p>그런데 과연 Blocking된 쓰레드가 많아진다고 쓰레드를 무수히 많이 불러오는 것이 항상 좋을까요?</p>\n<p><img src=\"https://i.imgur.com/yQLmP2Y.png\"></p>\n<p>당연히 아니겠죠..</p>\n<p>쓰레드들이 Blocking된 상태에서 추가적으로 쓰레드를 계속 불러온다면, 더 이상 코어가 쓰레드를 불러올 수 없는 상태가 됩니다.</p>\n<p>해당 현상을 <strong>Thread Explosion</strong>이라고 부릅니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Swift는 이를 해결하기 위해 <code>DispatchSemaphore</code>와 같은 기능을 제공하고 있기는 합니다. 문제는 너무 복잡하다는 것이죠..!</p></blockquote>\n<p>Thread Explosion 현상이 발생하면 OS는 여러 문제를 마주칩니다.</p>\n<p><img src=\"https://i.imgur.com/oTDfwu0.png\"></p>\n<ul>\n<li><strong>메모리 오버헤드</strong>: Block된 쓰레드는 각자 <strong>메모리와 리소스를 점거</strong>하고 있습니다. 다른 쓰레드의 unlock을 위해 필요한 리소스를 점거하고 있을 수도 있죠.</li>\n</ul>\n<p><img src=\"https://i.imgur.com/MrBlrHa.png\"></p>\n<ul>\n<li><strong>스케줄링 오버헤드</strong>: CPU의 코어는 쓰레드간의 전환을 위해 <strong>컨텍스트 스위칭(Context Switching)</strong> 이라는 작업을 수행해야 합니다. 쓰레드가 폭발적으로 많아지면 컨텍스트 스위칭도 빈번히 일어나 불필요한 작업이 늘어납니다.</li>\n</ul>\n<p>자 그래서 Swift는 이런 현상을 어떻게 해결했느냐?</p>\n<h2 id=\"async-x2F-await\"><a href=\"#async-x2F-await\" class=\"headerlink\" title=\"async &#x2F; await\"></a>async &#x2F; await</h2><p>새로운 Swift의 <strong>asynchronous</strong> 개념 <code>async / await</code>와 <strong>concurrency</strong>를 통해서죠.</p>\n<p>실은 멀티 쓰레딩의 이러한 오버헤드들은 이전부터 다양한 언어와 운영체제 전문가들에게 문제시 되어왔습니다.</p>\n<p>이들이 제시한 방법은 바로 <strong>Coroutine</strong> 방식이였습니다.</p>\n<p>오래전 멀티쓰레딩 방식이 제시되고 통용되기 시작하며 자연스럽게 버려졌던 Coroutine 방식이 현대에 와서 다시 연구되고 발전하고 있죠.</p>\n<p>실제로 Python, Kotlin과 같은 언어들이 적극적으로 Coroutine 방식을 사용하고 있습니다.</p>\n<p>그래서 Coroutine 방식은 어떤 방식이냐?</p>\n<p><strong>코루틴(Coroutine)</strong> 은 <strong>CPU의 코어 개수만큼</strong>만 쓰레드를 만들고 쓰레드를 차단하는 대신 <strong>작업을 막아둠</strong>으로써 <strong>컨텍스트 스위칭을 차단</strong>합니다.</p>\n<p><img src=\"https://i.imgur.com/G8fVpID.png\"></p>\n<p>Swift 용어로 바꾸어볼까요?</p>\n<p>Swift <strong>Concurrency</strong>는 <strong>쓰레드의 차단(Blocking)을 없애</strong>고 작업의 재실행(Resumption of Work)를 추적하는 <strong>continuation</strong>이라는 객체를 통해 Context Switching 대신 <strong>같은 쓰레드 내에서 Continuation Switching</strong>을 수행하여 동시성 프로그래밍을 지원합니다.</p>\n<p>자 Concurrency가 <em>(모순적이게도)</em> 현대적이고 좋다는 건 알았어요.</p>\n<p>그래서 <code>async / await</code>은 어떻게 사용할까요? 😒</p>\n<p>WWDC에서도 사용한 기존의 <code>@escaping</code> 클로저를 사용하는 예시를 가져와봤어요.</p>\n<p><img src=\"https://i.imgur.com/BJ4S8qO.png\"></p>\n<p>시스템적인 단점 말고 코드 작성의 측면에서 <code>@escaping</code> 클로저 방식은 세가지 단점을 가지고 있습니다.</p>\n<ol>\n<li><code>completion</code> 클로저 호출을 까먹기 쉽습니다. (여러군데에 필요)</li>\n<li><code>callback</code>이 중첩해서 발생하는 경우가 많습니다.</li>\n<li>코드 가독성이 떨어집니다.</li>\n</ol>\n<p>자 그런데 <code>async / await</code>를 사용한 코드로 바꿔보면요?</p>\n<p><img src=\"https://i.imgur.com/5VqRh34.png\"></p>\n<p>엄청 짧아지고 수많았던 중괄호들이 사라졌어요! 👏</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>함수의 파라미터와 반환타입 중간에 <strong><code>async</code></strong> 를 붙여줌으로써 <strong>해당 함수가 비동기성</strong>이다 라는 것을 나타내줍니다!</p>\n<p><code>throws</code>를 통해 해당 함수가 에러를 방출할 수 있다라는 것도 함께 명시해줄 수 있습니다.</p>\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p><code>async</code>로 정의된 함수를 호출하기 위해서는 <strong>Concurrent Context 내부</strong>에서 <strong><code>await</code> 키워드</strong>를 붙여주어야 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let (data, response) &#x3D; try await URLSession.shared.data(for: request)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>주의할 점은 정의할때는 순서가 <code>async throws</code>지만, 사용할때는 <code>try await</code> 순서라는 것을 알아두어야합니다.</p>\n<p><code>await</code> 키워드는 해당 라인이 <strong>Suspension Point</strong>라는 것을 명시하는 역할을 합니다.</p>\n<h3 id=\"Suspend\"><a href=\"#Suspend\" class=\"headerlink\" title=\"Suspend\"></a>Suspend</h3><p><code>await</code> 포인트를 만나면 된다는 Suspend는 또 뭘까요?</p>\n<p><strong>Suspend</strong>는 <strong>“해당 스레드가 다른 동작을 수행할 수 있도록 스레드의 통제권을 시스템에게 넘겨준다”</strong> 라는 것을 의미합니다.</p>\n<p><img src=\"https://i.imgur.com/tmlzOQQ.png\"></p>\n<p>일반적인 <strong>synchronous</strong>한 코드의 경우에는 위와 같이 동작합니다.</p>\n<p><code>fetchThumbnail</code> 함수에서 <code>thumbnailURLRequest</code> 함수를 호출하고 있습니다.</p>\n<p>이 때 두 함수 모두 sync 함수이기 때문에 <code>fetchThumbnail</code> 함수는 <code>thumbnailURLRequest</code> 함수에게 <strong>쓰레드 제어권을 넘겨줍니다.</strong></p>\n<p><code>thumbnailURLRequest</code> 함수는 수행에 얼마나 많은 시간이 걸리던 쓰레드를 점유하고 작업이 완료되면 <strong>제어권</strong>을 다시 Caller인 <code>fetchThumbnail</code> 함수에게 <strong>돌려줍니다.</strong></p>\n<p>이 경우 쓰레드는 이 두 작업 외의 <strong>다른 작업들을 수행할 수 없습니다.</strong></p>\n<p><img src=\"https://i.imgur.com/blAu5WR.png\"></p>\n<p><strong>asynchronous</strong>한 경우에는 어떨까요?</p>\n<p><code>fetchThumbnail</code> 함수가 <code>data(for: request)</code> 함수에게 쓰레드 제어권을 넘겨주는 것까지는 동일합니다.</p>\n<p>하지만 <code>await</code>로 명시된 <code>data(for: request)</code> 함수는 <strong><code>async</code> 함수</strong>이기 때문에 중간에 <strong>suspend</strong> 될 수 있습니다.</p>\n<p><code>async</code> 함수가 suspend되면, <strong>쓰레드 제어권</strong>은 다름아닌 <strong>시스템</strong>에게 넘겨집니다.</p>\n<p>그러면 시스템은 다른 작업을 할 수 있게 되는 것이죠.</p>\n<p>시스템은 <strong>알아서</strong> suspend 되거나 수행이 필요한 다른 작업들의 우선순위들을 판단해가며 처리해나갑니다.</p>\n<p>시스템이 suspend 되었던 함수의 처리가 필요해졌다고 판단하는 순간, 쓰레드 제어권은 다시 <code>async</code> 함수였던 <code>data(for: request)</code> 함수에게 재개(<strong>resume</strong>)되고 이후의 작업들이 수행될 수 있게 됩니다.</p>\n<p>자 다시 돌아가서 Suspend가 이루어지는 과정을 자세히 살펴볼게요.</p>\n<p><img src=\"https://i.imgur.com/OlVlEgJ.png\"></p>\n<p><strong>Synchronous</strong>한 함수의 경우 메모리의 <strong>스택 영역</strong>에 함수들이 <strong><code>push</code></strong> 되며 쌓이게 됩니다.</p>\n<p>그러다가 함수의 실행이 끝나면 <strong><code>pop</code></strong> 되어 스택에서 제거되죠.</p>\n<p>아주 간단명료합니다.</p>\n<p>그러면 <strong>asynchronous</strong>한 경우에는 어떨까요?</p>\n<p><img src=\"https://i.imgur.com/kXukxOi.png\"></p>\n<p><strong><code>async</code> 함수</strong>라고 명시되어 있는 경우, scope 전체를 한 번 돌며 <strong>suspension point(<code>await</code>)</strong> 마다 <strong>어떤 변수</strong>가 <strong>여러 쓰레드</strong>에서 사용되는지를 파악합니다.</p>\n<p>예시의 경우, <code>id</code>와 <code>particle</code>은 쓰레드 사이를 오갈 필요가 없는 <strong>local 변수</strong>이죠?</p>\n<p>따라서 해당 변수들은 synchronous 함수의 경우와 마찬가지로 <strong>스택 영역</strong>에 저장됩니다.</p>\n<p><img src=\"https://i.imgur.com/hVDxMMn.png\"></p>\n<p>그렇다면 <code>await</code>에서 사용된 <code>newArticles</code> 변수(<em>파라미터로 받았기 때문에 상수이지만 편의상 변수라고 하겠습니다.</em>)의 경우는 어떨까요?</p>\n<p><code>suspend</code>되는 코드는 잠깐 멈춰있다가 다시 실행되야하기 때문에 필요한 변수들을 멈추기 <strong>이전과 이후 모든 시점에 사용</strong>할 수 있어야 합니다.</p>\n<p>Swift는 이를 위해 <strong>Heap 영역</strong>을 활용합니다.</p>\n<p><img src=\"https://i.imgur.com/zt4JmwU.png\"></p>\n<p><code>add</code> 함수를 힙 영역에 저장하고 나면 스택 영역에는 해당 프레임을 계속 붙잡고 있을 필요가 없기 때문에 실행이 필요한 <code>save</code> 함수로 대체됩니다.</p>\n<p><img src=\"https://i.imgur.com/XmdB0tW.png\"></p>\n<p>이 <code>save</code> 함수 안에 마찬가지로 <code>await</code> 코드가 담겨있다고 가정해보면, 해당 <code>save</code> 함수 또한 힙 영역으로 옮겨진 후 시스템에 쓰레드 제어권을 넘겨주게 됩니다.</p>\n<p><img src=\"https://i.imgur.com/K1SLhLB.png\"></p>\n<p>쓰레드는 다른 작업들(<code>otherWork1</code>, <code>otherWork2</code>)을 마찬가지로 힙 영역에 보관하며 수행합니다.</p>\n<p>따라서 힙 영역에는 <code>async</code> 함수들의 스택들이 모여있게 되는 것이죠.</p>\n<p><strong>Continuation</strong>이라는 것이 이런 힙 영역의 <code>async</code> 스택을 대표한다고 합니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Continuation이란 단순히 <code>await</code> 이후에 수행되는 작업들을 표현하는 말이라고 합니다. <code>withCheckedThrowingContinuation(continuation:)</code>과 같은 메서드에서 사용되니 참고해주세요!</p></blockquote>\n<p><img src=\"https://i.imgur.com/njgQmFm.png\"></p>\n<p><strong>작업이 없는 쓰레드</strong>가 생기고 힙 영역에 저장된 <code>async</code> continuation이 다음 작업으로 선택되면, 힙 영역에 있던 작업 스택을 하나씩 다시 <strong>스택 영역</strong>으로 불러와 차근차근 작업을 수행합니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>이 때, <strong>작업이 없는 쓰레드</strong>라는 것은 <code>await</code> 이전에 수행하던 쓰레드일수도 있고 아닐 수도 있습니다. <strong>보장되지 않는다</strong>는 것이죠.</p></blockquote>\n<p>자 그래서 이 <code>async / await</code>를 이용한 Concurrency는 어떻게 사용하면 될까요?</p>\n<h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2><p><img src=\"https://i.imgur.com/N9K39Fh.png\"></p>\n<p>위의 예시를 여러번 수행하는 또 다른 예시입니다.</p>\n<p>이 예시는 상당히 좋은 예시이고 아주 정상적으로 잘 동작하는 예시입니다.</p>\n<p>하지만 한 가지 개선이 필요한 부분이 있습니다.</p>\n<p><code>for in</code>을 통해서 여러번의 <code>URLSession</code>을 <code>await</code>하는 것인데요.. 이런 식의 구현은 <strong>한 번에 하나의 루프</strong>만을 수행할 수 있습니다.</p>\n<p><code>async</code>하게는 구현하였지만 <strong>concurrent하지는 못한</strong> 것입니다.</p>\n<p>또한 <code>fetchThumbnails()</code>이라는 함수 또한 결국에는 <code>async</code> 함수이기 때문에 프로젝트의 어딘가에서는 <strong>async 컨텍스트</strong>를 제공해줄 곳이 필요합니다.</p>\n<p>이 때 <strong>Task</strong>가 등장합니다.</p>\n<p><strong>Task</strong>는 concurrent한 코드 수행을 위한 <strong>새로운 async 컨텍스트를 제공</strong>합니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>async</code> 함수를 단순히 call 하는 것은 Task를 생성하지 않습니다! (GCD 등을 사용하면 call 할 수는 있습니다.)</p></blockquote>\n<p>하지만 어떤 Task들이 있나 보기 이전에 <strong>Task Tree</strong>라는 개념을 알아두어야 합니다.</p>\n<h3 id=\"Task-Tree\"><a href=\"#Task-Tree\" class=\"headerlink\" title=\"Task Tree\"></a>Task Tree</h3><p><strong>Task Tree</strong>는 Task의 <strong>취소(cancellation)</strong>, <strong>우선순위(priority)</strong>, <strong>지역변수(task-local variables)</strong> 등의 속성들을 결정하는 아주 중요한 개념입니다.</p>\n<p>기본적으로는 어떤 <code>async</code> 함수가 다른 <strong><code>async</code> 함수를 호출</strong>하면, 두 함수를 호출하는 데에는 <strong>같은 Task</strong>가 사용됩니다.</p>\n<p><img src=\"https://i.imgur.com/OHtAIMh.png\"></p>\n<p>아래 <code>async-let</code>에서 사용된 예시의 경우를 먼저 한 번 가져와봤습니다.</p>\n<p><code>fetchOne()</code> 함수가 두 가지의 Task <code>data</code>와 <code>metadata</code>를 호출하는 경우입니다.</p>\n<p><code>fetchOneThumbnail()</code> 함수는 두 가지 Task를 child로 갖고 있다고 했습니다.</p>\n<p>이처럼 한 Task가 다른 Task를 실행하면 실행된 Task들은 현재 함수가 실행되고 있는 Task의 <strong>Child Task</strong>가 됩니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Task는 함수에 종속된 개념은 아니지만 함수의 생명주기에 영향을 받을 수는 있습니다.</p></blockquote>\n<p>그리고 <strong>Parent Task</strong>는 종속된 <strong>모든 Child Task들이 종료되기 전</strong>에는 <strong>종료될 수 없습니다</strong>.</p>\n<p>만약 <code>metadata</code> Task가 에러를 <code>throw</code>하면서 종료되었다는 상황을 가정해봅시다.</p>\n<p>두 Task는 같은 <code>guard</code> 문 내에 있기 때문에 즉시 에러를 <code>throw</code>하고 함수를 종료할 수 있겠죠?</p>\n<p>하지만 Task에서는 그렇지 않습니다. 정확히 말하면 <strong>“즉시”</strong> 종료하지는 않습니다.</p>\n<p><code>metadata</code> Task가 실패했더라도 <code>data</code> Task는 여전히 동작중일 것입니다.</p>\n<p>따라서 해당 Task가 <strong>취소되었다는 정보를 제공</strong>해주고 Task가 <strong>종료되기를 기다렸다</strong>가 모든 Task가 <strong>종료된 시점</strong>에 함수가 종료됩니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>여기서 <strong>취소되었다(cancelled)</strong> 라는 것은 해당 Task를 종<strong>료시키는 것이 아니고</strong> <strong>결과가 더 이상 필요없다</strong>는 것을 알려줄 뿐입니다.</p></blockquote>\n<p><img src=\"https://i.imgur.com/IrOtkbg.png\"></p>\n<p>만약 취소된 Task가 <strong>Child Task</strong>를 가지고 있다면 <strong>모든 Child Task들 또한 취소</strong>됩니다.</p>\n<p>이러한 Task Tree 동작은 ARC와 같이 실수로 벌어지는 <strong>Task Leak</strong>를 방지하기 위함이라고 합니다.</p>\n<p>이런 Task Tree의 특성을 정리하면 다음과 같이 표현할 수 있습니다.</p>\n<p><strong>Task의 취소</strong>는 <strong>협력적(cooperative)</strong> 으로 이루어집니다.</p>\n<ol>\n<li>Task는 취소되더라도 즉시 종료되지 않습니다.</li>\n<li>Task의 취소 여부는 어디에서도 가능합니다. (synchronous한 코드에서도)</li>\n</ol>\n<p>이는 개발자가 Task가 취소되었을 때의 동작을 구현할 수 있게 하기 위함이라고 하네요.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>이 말은 Task가 오래 걸리는 동작일수록 취소에 대응하는 코드가 꼭 필요하다라는 뜻 같습니다.</p></blockquote>\n<p>설명만으로는 무슨 말인지 잘 모르겠으니 예시를 다시 가져와보죠!</p>\n<p><img src=\"https://i.imgur.com/4i9k1jL.png\"></p>\n<p>위와 같이 concurrent한 동작이 <strong>수행되기 전</strong>에 <code>Task.checkCancellation()</code>나 <code>if Task.isCancelled &#123; break &#125;</code>을 통해 불필요한 썸네일 생성의 동작을 방지하고 에러를 방출할 수 있습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>위 예시의 경우 Task가 취소되었더라도 thumbnails에는 취소되기 이전에 성공한 데이터들이 담겨있고, 그 데이터들이 그대로 반환됩니다. 빈 데이터 등의 결과는 UI에 에러를 발생시킬 수 있기 때문에 염두에 두고 작업해야합니다.</p></blockquote>\n<p>이제 우리는 Task가 언제 취소되거나 완료되는지를 알았습니다! 😎</p>\n<p>드디어 Swift가 제공하는 다양한 형태의 <strong>Task</strong>를 알아볼 때가 되었네요. 하나씩 살펴보죠!</p>\n<h4 id=\"Structured-Tasks\"><a href=\"#Structured-Tasks\" class=\"headerlink\" title=\"Structured Tasks\"></a>Structured Tasks</h4><h5 id=\"async-let-Tasks\"><a href=\"#async-let-Tasks\" class=\"headerlink\" title=\"async-let Tasks\"></a>async-let Tasks</h5><p><img src=\"https://i.imgur.com/hs0BOj3.png\"></p>\n<p>지금까지의 <code>URLSession.data()</code> 함수는 위와 같이 사용되었습니다.</p>\n<p>화살표의 방향대로 <strong>단 한가지의 흐름</strong>(단방향)만이 존재합니다.</p>\n<p>하지만 우리는 <code>URLSession</code>은 시간이 걸리는 함수이기 때문에 수행 시간동안 다른 작업들이 수행되길 원합니다.</p>\n<p><img src=\"https://i.imgur.com/dcjOSV3.png\"></p>\n<p><code>async-let</code>을 사용하면 위처럼 흐름이 두 가지로 나뉘어집니다.</p>\n<p><strong>Child Task</strong>가 생성되고, <code>URLSession.data()</code> 함수를 <strong>async하게 실행</strong>함과 동시에 <code>result</code>에는 <strong>임시 값(placeholder)</strong> 을 넘겨준채로 <strong><code>await</code> 키워드가 등장할 때까지</strong> 수행합니다.</p>\n<p><code>await</code>에서 기다리던 작업은 <code>async</code> 함수가 끝이 나면 <code>result</code> 값을 <strong>대체</strong>하여 사용합니다.</p>\n<p><img src=\"https://i.imgur.com/6AkTzcH.png\"></p>\n<p>그렇다면 위 코드를 <code>async-let</code>을 사용하는 방식으로 바꾸려면 어떻게 해야할까요?</p>\n<p><code>try await</code>은 <strong>child task</strong>에게 작업을 넘겨줬기 떄문에 더 이상 해당 함수를 호출하는 지점에서는 필요가 없습니다.</p>\n<p><strong>Parent task</strong>에서 결과로 나온 변수를 <strong>사용</strong>할 때 필요하죠.</p>\n<p>따라서 다음과 같이 바꿔줄 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/xMhYuVI.png\"></p>\n<p>각각의 <code>URLSession</code>에서 <code>try await</code>을 제거하는 대신 맨 앞에 <code>async</code>를 붙여주고,</p>\n<p><strong>Parent task</strong>인 <code>fetchOneThumbnail()</code> 함수에서 <code>data</code>와 <code>metadata</code>가 필요한 순간에 <strong><code>try await</code></strong> 을 사용하고 있습니다!</p>\n<h5 id=\"Group-Tasks\"><a href=\"#Group-Tasks\" class=\"headerlink\" title=\"Group Tasks\"></a>Group Tasks</h5><p><code>async-let</code>은 수행해야하는 <strong>Task의 개수가 정해져있을 때</strong> 유용합니다.</p>\n<p><img src=\"https://i.imgur.com/OHtAIMh.png\"></p>\n<p>다시 한번 위 예시의 경우를 보면, 몇 개의 썸네일을 생성하던지 간에 <code>fetchOne</code>이라는 Task는 <strong>고정적으로 두 개</strong>의 <strong>Child Task</strong>를 가지고 있습니다.</p>\n<p>하지만 <code>id</code>의 개수에 따라서는 수행할 <code>fetchOne()</code> 함수가 실행될 Task의 개수는 달라지겠죠?</p>\n<p><strong>Task Group</strong>은 이런 경우에 유용합니다.</p>\n<p><strong>Task Group</strong>은 <strong>동적 개수의 Task의 수행이 동시에 필요할 때</strong> 사용되기 위해 고안되었습니다.</p>\n<p><img src=\"https://i.imgur.com/GpMeSw2.png\"></p>\n<p><strong><code>withThrowingTaskGroup(of:)</code></strong> 를 통해서 <strong>Task Group</strong>을 만들어줄 수 있습니다.</p>\n<p>이 함수는 <strong>Child Task를 생성</strong>하는 <strong><code>group</code></strong> 이라는 인스턴스를 사용하는 Context를 제공합니다.</p>\n<p>또한 for 루프의 각 루프들은 <code>group.async</code>를 통해 <strong>비동기적으로 수행</strong>되기 때문에 <strong>랜덤한 시기</strong>에 <strong>순서 상관 없이</strong> 수행될 수 있습니다.</p>\n<p><code>group</code> 인스턴스가 루프를 전부 돌았더라도 <strong>Task Tree의 특성</strong>에 의해 <strong>모든 Task가 종료될 때까지 <code>await</code>된다</strong>는 것도 알 수 있겠죠!</p>\n<p>그런데.. 모든게 평화로워 보이는 위 코드는 놀랍게도 <strong>심각한 에러</strong>를 가집니다.. 😰</p>\n<p>심지어 빌드도 안되는 컴파일러 에러를 내뿜죠..</p>\n<p><img src=\"https://i.imgur.com/OkgBhZ1.png\"></p>\n<p>바로 <strong>Data Race Issue</strong>가 발생하기 때문입니다..</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>Data Race Issue</strong>는 한 번에 <strong>여러 개의 Task</strong>에서 <strong>하나의 데이터</strong>에 접근할 때 발생하는 에러입니다. 하나의 변수는 <strong>한 번에 하나의 연산</strong>만 가능하지만, <strong>여러 Task에서 동시에 값을 수정</strong>하려고 하면 크러쉬가 나거나 데이터가 손상되게 됩니다..</p></blockquote>\n<p>이 경우에는 하나의 <code>thumbnails</code> 딕셔너리에 여러 Task들이 동시에 값을 넣어주고 있죠?</p>\n<p>이는 Concurrency 프로그래밍을 할 때 개발자들이 흔히 하는 실수 중에 하나입니다.</p>\n<p>Data Race Issue의 해결은 개발자에게 달려있었습니다.</p>\n<p>하지만 업데이트된 Swift Concurrency는 이를 컴파일러에서 미리 발견하여 에러를 발생시켜주는 것이죠! 👏 <em>(이렇게 들으니까 멋지죠?)</em></p>\n<p>그래서 에러를 잡아주긴 하는데 해결은 어떻게 해야할까요?</p>\n<p>Task는 사실 <code>@Sendable</code> 클로저라는 클로저에 의해 감싸져 있습니다.</p>\n<p><code>@Sendable</code> 클로저의 캡처는 독특하게도 <code>mutable</code> 변수의 값을 캡처하지 못합니다.</p>\n<p>그러면 어떤 값들을 캡처할 수 있는가 하면?</p>\n<p><strong>값 타입</strong>(<code>Int</code>, <code>String</code>, …) 변수, <strong><code>actors</code></strong>, 고유한 <strong>synchronization을 가진 <code>class</code></strong> 를 캡처하거나 사용할 수 있습니다.</p>\n<p>다시 예시로 돌아가서 에러를 고쳐볼게요..</p>\n<p><img src=\"https://i.imgur.com/ArzVjpZ.png\"></p>\n<p><code>thumbnails</code>에 직접적으로 값을 대입하는 대신, <code>String</code> 타입과 <code>UIImage</code> 타입의 튜플을 반환하는 방식으로 변경합니다.</p>\n<p>그 후에 <code>for await</code> 루프를 통해 순차적으로 값들을 <code>thumbnails</code>에 대입해주고 있습니다.</p>\n<p><strong><code>AsyncSequence</code> 프로토콜</strong>을 채택한 값을 다루고 있다면 <code>for await</code> 루프를 사용해볼 것을 권장하고 있네요.</p>\n<p>자.. 여기까지 알아본 <strong><code>async-let</code></strong> 과 <strong>Grouped Tasks</strong>는 <strong>Structured Task</strong>라는 각자의 hierarchy가 정돈된 Task들을 처리하는 방식이였습니다.</p>\n<p>하지만 언제나 정돈된 방식을 사용할 수 있는 건 아니기 때문에 Swift는 <strong>Unstructured Tasks</strong>라는 API를 추가로 제공하고 있습니다.</p>\n<h4 id=\"Unstructured-Tasks\"><a href=\"#Unstructured-Tasks\" class=\"headerlink\" title=\"Unstructured Tasks\"></a>Unstructured Tasks</h4><p>Hierarchy가 정돈되지 않은 Task에는 어떤 Task들이 있을까요?</p>\n<p>먼저, <strong>Parent Task가 존재하지 않을</strong> 수 있습니다. <strong>async하지 않은 컨텍스트</strong>에서 <strong>async한 Task를 시작</strong>해야할 때가 이런 경우죠.</p>\n<p>또 Task가 하나의 scope를 넘어 <strong>여러 scope에서 이루어지도록</strong> 할 필요가 있을 때도 있을겁니다.</p>\n<p>보통 <strong><code>delegate</code> 패턴</strong>을 사용할 때 흔히 일어나는 일이라고 하네요.</p>\n<p><img src=\"https://i.imgur.com/hP2cM4D.png\"></p>\n<p>위 예시를 봅시다..</p>\n<p><strong><code>delegate</code></strong> 함수인 <code>collectionView(willDisplay:, forItemAt)</code> 함수는 UI 레이어의 함수이기 때문에 async하지 않습니다.</p>\n<p>하지만 데이터를 받아오는 <code>fetchThumbnails()</code> 함수는 async 함수이죠.</p>\n<p>이럴 때가 바로 <strong>Unstructured Task</strong>를 사용할 때입니다.</p>\n<p><img src=\"https://i.imgur.com/kHwb1FR.png\"></p>\n<p>간단하게 async 처리가 필요한 곳은 <code>Task</code>로 감싸줍니다.</p>\n<p>런타임동안 이 <strong>Task를 생성하는 부분</strong>을 마주치게 되면, <strong>수행하는 scope와 같은 actor</strong>에서 실행되도록 예약을 해둡니다.</p>\n<p>예시의 경우에는 <strong>MainActor</strong>에서 실행이 될 겁니다.</p>\n<p>이렇게 사용하기 간편하다면 단점도 당연히 있겠죠?</p>\n<p>Task의 생명주기가 scope에 종속되지 않고 synchronous한 코드 중간에서도 호출이 될 수 있기 때문에 Structured Task에서 자동으로 수행될 수 있었던 <strong>취소</strong>와 <strong>await</strong>를 개발자가 직접 해줘야 합니다.</p>\n<p><img src=\"https://i.imgur.com/uld4DAv.png\"></p>\n<p>이 경우, Task를 생성한 뒤에 <code>thumbnailTasks</code>라는 딕셔너리에 저장하였습니다.</p>\n<p>그러면 나중에도 언제든지 접근해서 작업을 취소할 수 있겠죠?</p>\n<p><code>defer</code>문을 사용해 <strong>Task가 끝난 시점에 저장된 Task를 해제</strong>함으로써 이미 <strong>완료된 Task를 취소하는 일도 방지</strong>해둔 것을 볼 수 있네요.</p>\n<p>🙋 어라 그런데.. 같은 데이터에 여러 Task가 동시에 접근하면 안된다고 하지 않았나요?</p>\n<p>맞습니다.. 하지만 이 경우에는 <strong><code>@MainActor</code></strong>, 즉 메인쓰레드에서 이루어지기 때문에 절대로 동시에 일어날 일이 없습니다.</p>\n<p>셀이 화면에서 벗어나면 작업을 취소해도 되겠죠.</p>\n<p><img src=\"https://i.imgur.com/bDfgWq7.png\"></p>\n<p>다음과 같이 <strong><code>task.cancel()</code></strong> 로 Task를 취소해줄 수 있습니다.</p>\n<h4 id=\"Detached-Tasks\"><a href=\"#Detached-Tasks\" class=\"headerlink\" title=\"Detached Tasks\"></a>Detached Tasks</h4><p>어라 뭐가 하나 또 있죠…?</p>\n<p>Unstructured Tasks는 어떤 스코프에서도 수행될 수 있는 Task였습니다. 하지만 \b어떤 컨텍스트에서 시작되었는지는 중요한 요소였습니다.</p>\n<p>해당 scope의 변수도 사용해야 하고, </p>\n<p><strong>Detached Tasks</strong>는 그 어떤 것도 <strong>상관이 없을 떄</strong> 사용하는 Task입니다.</p>\n<p>Detached Tasks는 <strong>컨텍스트로부터 독립적</strong>입니다.</p>\n<p>시작된 scope에서 <strong>아무 값도 가져오지 않습니다</strong>.</p>\n<p>심지어 같은 actor에서 실행되도록 되어있지도 않아서 <strong>같은 우선순위를 갖지도 않습니다</strong>.</p>\n<p><img src=\"https://i.imgur.com/HnQ4DHp.png\"></p>\n<p>위 예시는 썸네일을 생성한 후에 로컬 디스크에 캐싱을 하는 작업을 Detached Task에서 작업하도록 하는 코드입니다.</p>\n<p>캐싱은 <code>@MainActor</code>에서 처리될 필요가 전혀 없죠.</p>\n<p>높은 우선순위를 가질 필요도 없습니다.</p>\n<p><strong><code>Task.detached(priority:)</code></strong> 를 통해서 간단하게 <strong>컨텍스트에서 독립</strong>된 <strong>Detached Task</strong>를 만들어줄 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/4nmJx28.png\"></p>\n<p>Detached Task에 <strong>Task Group</strong>을 사용해서 <strong>hierarchy</strong>를 만들어줄 수도 있습니다.</p>\n<p>여러가지 백그라운드 작업이 필요하지만 연결된 작업이 필요할 때 아주 유용하겠죠!</p>\n<h3 id=\"정리\"><a href=\"#정리\" class=\"headerlink\" title=\"정리\"></a>정리</h3><p><img src=\"https://i.imgur.com/vnsVMkB.png\"></p>\n<h2 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h2><p>끝난 줄 알았죠..?</p>\n<p>하지만 아직 많이 남았습니다. 🤯</p>\n<p>위에서 <strong>Actor</strong>라는 키워드가 사용되었었죠..?</p>\n<p>이게 뭔지도 알아봐야죠..</p>\n<p>Actor가 뭔지 알아보려면 마찬가지로 이미 한 번 살펴본 <strong>Data Race Issue</strong>와 관련되어 있다는 것을 알고 시작해야합니다.</p>\n<p><strong>Data Race</strong>는 <strong>여러 개의 Task</strong>에서 <strong>동시에 하나의 <code>mutable</code> 값에 접근</strong>하려고 하면 발생하는 문제였습니다.</p>\n<p>그렇다면 문제를 어떻게 해결할까요?</p>\n<p><strong>변하지 않는 데이터</strong>를 사용하거나 <strong>여러 Task에 걸쳐 사용되지 않도록</strong> 하면 해결되겠죠?</p>\n<p><img src=\"https://i.imgur.com/PiEJOBA.png\"></p>\n<p>그러면 이렇게 하면 되겠네요!</p>\n<p><code>let</code>으로 값이 고정된 값을 각 Task에서 <strong><code>mutable</code>한 값으로 복사</strong>한 뒤 작업을 해주면 되겠죠.</p>\n<p>아뇨 안됐습니다. 🙅‍♂️</p>\n<p>에러는 발생하지 않지만 Task마다 복사된 값은 서로의 값에 영향을 주지 못하거든요.</p>\n<p>그러면 이렇게 정리할 수 있습니다: <strong>각 Task들이 공유할 수 있는 <code>mutable</code> Task가 필요하다!</strong></p>\n<p>Swift는 이미 그런 feature들을 갖고 있습니다.</p>\n<p>이런 문제는 오래된 문제거든요..</p>\n<p><code>mutable</code> state를 동기화하는 작업은 로우레벨 단계에서 사용할 수 있는 <strong>Atomics</strong>, <strong>Locks</strong>, 더 높은 레벨에서 사용할 수 있는 <strong>Serial DIspatch Queues</strong>가 있습니다.</p>\n<p>이들은 모두 같은 역할을 하고 같은 문제를 갖고 있습니다.</p>\n<p>Shared mutable state에 Data Race 없이 접근할 수 있지만, 사용법이 조금이라도 어긋나면 바로 앱이 크러쉬된다는 것이죠.</p>\n<p><strong>Actors</strong>는 이런 문제를 해결하고 shared mutable state의 동기화를 좀 더 쉽게 이룰 수 있도록 등장했습니다.</p>\n<p><strong>Actors</strong>는 state를 <strong>다른 모든 프로그램에서 분리</strong>하여 관리합니다.</p>\n<p>그리고 해당 state에 접근하려면 무조건 <strong>actor 내부</strong>에 들어가야만 하죠.</p>\n<p><strong>Actor</strong>는 조금 특이하게 사용됩니다.</p>\n<p>새로운 타입이거든요</p>\n<p><img src=\"https://i.imgur.com/4uqjN9J.png\"></p>\n<p>마치 <code>struct</code>, <code>enum</code>, <code>class</code>와 같이 <strong>프로퍼티</strong>, <strong>메서드</strong>, <strong>생성자</strong> 등을 가집니다.</p>\n<p><strong><code>protocol</code></strong> 과 <strong><code>extension</code></strong> 또한 사용할 수 있습니다.</p>\n<p>또, actor는 shared mutable state에 접근하기 위해 만들어진 만큼 <code>class</code>와 같은 <strong>참조 타입</strong>입니다.</p>\n<p>사용법은 <code>class</code>와 동일합니다.</p>\n<p>한 가지 주의할 점이 있다면 <code>class</code>와는 다르게 <strong>상속</strong>을 지원하지는 않습니다!</p>\n<p>그리고 가장 중요한 점은 actor에서 정의된 값들은 <strong>동시에 접근되지 않도록 보장</strong>되어 있다~라는 점입니다.</p>\n<p><img src=\"https://i.imgur.com/uZlj9lu.png\"></p>\n<p>위의 예시에 적용해보면 이렇게 됩니다.</p>\n<p>같은 값에 접근하지만, 절대 동시에 접근할 수는 없기 때문에 순서대로 2, 1이나 1, 2가 출력될겁니다.</p>\n<p>하지만 suspend된 작업이 actor 안에서 얌전히 차례를 기다릴 것이라는 보장은 되는 걸까요?</p>\n<p>우리는 이미 그런 역할을 하는 키워드를 알고 있습니다.</p>\n<p><img src=\"https://i.imgur.com/Xpv0i3w.png\"></p>\n<p>actor의 외부에서는 <strong><code>await</code></strong> 키워드를 통해 해당 작업이 <strong>suspendable</strong>하다는 것을 명시해줄 수 있습니다.</p>\n<p>하지만 actor의 내부에서는 이와 같은 키워드는 필요가 없죠.</p>\n<p>모든 코드가 <strong>synchronous하게 실행</strong>되기 때문에 동시성 프로그래밍의 문제를 신경쓰지 않고 작업할 수 있습니다.</p>\n<h3 id=\"Actor-Reentrancy\"><a href=\"#Actor-Reentrancy\" class=\"headerlink\" title=\"Actor Reentrancy\"></a>Actor Reentrancy</h3><p><img src=\"https://i.imgur.com/KBfgXuf.png\"></p>\n<p>위 코드는 이미지를 캐싱하는 작업을 수행하는 <strong>actor</strong>입니다.</p>\n<p>문제는 <code>await</code>에서 발생합니다.</p>\n<p>이미지를 다운로드하는 과정은 시간이 오래 소요되는 작업이니 <code>await</code>을 사용하는 것은 올바른 접근입니다.</p>\n<p><img src=\"https://i.imgur.com/twvj2ww.png\"></p>\n<p>하지만 동시에 두 군데에서 <strong>같은 url의 이미지</strong>를 받아오길 원하고, 하나의 작업이 수행되는 동안 <strong>서버의 이미지가 교체</strong>되는 상황이 있다면 어떻게 될까요?</p>\n<p>두 작업은 동시에 요청됐음에도 불구하고 <strong>다른 이미지</strong>를 받아오게 될겁니다.</p>\n<p><img src=\"https://i.imgur.com/hZhXsLf.png\"></p>\n<p>이 경우에는, 이미 url에 해당하는 이미지가 있다면 그 이미지를 불러와 사용하고, 없다면 새로운 이미지를 넣는 것으로 해결하였습니다.</p>\n<p>이와 같이 actor 내부에서 <code>await</code>을 사용하는 것은 숨겨진 버그를 유발할 수 있기 때문에 주의가 필요합니다.</p>\n<p>이런 과정을 actor에 재진입하여 작업을 수행한다고 해서 <strong>Actor Reentrancy</strong>라고 부릅니다.</p>\n<p>다음 세 가지를 항상 생각해가며 코드를 짜봅시다.</p>\n<ol>\n<li>되도록 synchronous하게 데이터를 mutate 시킨다.</li>\n<li><code>await</code>에서 suspend된 동안 state가 바뀔 수 있음을 생각한다.</li>\n<li><code>await</code> 후에 조건문 등을 통해 state가 예상범위 안인지 체크한다.</li>\n</ol>\n<h3 id=\"Actor-Isolation\"><a href=\"#Actor-Isolation\" class=\"headerlink\" title=\"Actor Isolation\"></a>Actor Isolation</h3><p>Actor는 다른 프로그램들과 <strong>독립적</strong>으로 있는 존재라고 했었죠?</p>\n<p>따라서 외부에서 actor에 접근할 떄는 이런 독립성을 해치면서 접근할 수는 없습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>여기서부터 조금 아득해집니다.. 주의하세요… 🫠</p></blockquote>\n<h4 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h4><p><img src=\"https://i.imgur.com/UfZjadS.png\"></p>\n<p>이 경우 <code>Equatable</code> 메서드는 <strong><code>static</code></strong> 이고 파라미터로 받는 두 actor 타입 값의 외부에 있으니까 가능한 문법입니다.</p>\n<p><img src=\"https://i.imgur.com/GhUS1Y5.png\"></p>\n<p>반면 이 경우에는 허용되지 않습니다.</p>\n<p><code>hash(into:)</code> 함수는 <strong>actor 내부</strong>에 들어가 <strong>값을 변경</strong>하고, <strong>async하지도 않기 때문</strong>입니다.</p>\n<p>하지만 이상한 점이 있습니다. 😕</p>\n<p>actor 내부에 들어가는 것은 맞지만, 실제로 actor가 갖고있는 값을 변경하는 것은 아니거든요..</p>\n<p><img src=\"https://i.imgur.com/9WaS0jv.png\"></p>\n<p>그런 경우에는 <code>nonisolated</code> 키워드를 붙여 해결할 수 있습니다.</p>\n<p>하지만 끝이 아닙니다..</p>\n<p>이 경우에는 사용하는 actor의 프로퍼티 <code>idNumber</code>가 <strong>immutable</strong>한 값이거든요.</p>\n<p>하지만 mutable한 값을 사용하려고 하면…?</p>\n<p><img src=\"https://i.imgur.com/YfVeSeO.png\"></p>\n<p>어김없이 에러가 발생합니다.</p>\n<p><strong>외부에서 mutable한 값에 접근</strong>하는 것은 <strong>Data Race</strong>를 유발할 수 있거든요.</p>\n<h4 id=\"Closure\"><a href=\"#Closure\" class=\"headerlink\" title=\"Closure\"></a>Closure</h4><p>이번에는 클로저 안에서 실행되는 함수의 경우를 살펴봅시다.</p>\n<p><img src=\"https://i.imgur.com/yqAMbvI.png\"></p>\n<p>위 예시는 아무 문제가 없습니다.</p>\n<p>독립된 공간에 있는 <code>read()</code> 함수 안에 있는 (마찬가지로 독립된 공간에 있는)<code>readSome()</code> 함수가 <strong>synchronous</strong>하기 때문에 <strong>순차적으로 실행</strong>되기 때문이죠!</p>\n<p><img src=\"https://i.imgur.com/joyF9HO.png\"></p>\n<p>그렇다면 이 경우는 어떨까요..</p>\n<p><strong>Detached Task</strong>에 <code>read()</code> 함수가 있기 때문에 이 경우에는 클로저 안의 작업들이 <strong>독립된 공간에 있지 않고 밖으로</strong> 나가게 됩니다.</p>\n<p>때문에 해당 클로저는 actor에 있지 않고, <strong><code>await</code></strong> 키워드를 붙여 <strong>비동기적</strong>으로 처리되어야 합니다.</p>\n<p><img src=\"https://i.imgur.com/ka2pSN8.png\"></p>\n<p>자 이 경우를 봅시다..</p>\n<p><code>Book</code>이라는 인스턴스는 <code>class</code> 타입입니다. 참조 타입이니까 actor 안에 있지 못하고 <strong>외부</strong>에 위치해있죠.</p>\n<p>actor 안에 참조 타입의 값이 있는 것 자체는 아무 문제가 없습니다.</p>\n<p>문제는 해당 값에 <strong>접근</strong>을 할 때 발생하겠죠? (Data Race)</p>\n<p>여기서 익숙한 키워드가 등장합니다.</p>\n<ul>\n<li><strong>Sendable</strong></li>\n</ul>\n<p><strong>Sendable</strong> 타입은 다른 여러 actor들 사이에서 함께 사용될 수 있는 타입입니다.</p>\n<p>어떤 값을 각자의 actor로 복사하고, 복<strong>사된 값을 독립적으로 처리</strong>할 수 있다면 해당 값은 <strong>Sendable</strong>하다고 할 수 있습니다.</p>\n<p><strong>값 타입</strong>과 <strong>Actor 타입</strong>은 기본적으로 <strong>Sendable</strong>합니다.</p>\n<p>하지만 **클래스(참조 타입)**의 경우에는 고려해야할 사항이 있죠..</p>\n<ol>\n<li>클래스에 있는 **모든 값들이 immutable(<code>let</code>)**한 경우</li>\n<li>클래스 <strong>내부적으로 동기화(<code>lock</code>)를 구현</strong>한 경우</li>\n</ol>\n<p>하지만 대부분의 클래스는 그렇지 않기 때문에 Sendable이 아니라고 할 수 있습니다.</p>\n<p>함수는 기본적으로는 Sendable하지 않지만 <strong><code>@Sendable</code> 함수</strong>와 같은 새로운 타입의 함수를 사용하면 Sendable합니다.</p>\n<p><img src=\"https://i.imgur.com/lQtLpWi.png\"></p>\n<p>Sendable은.. 예상하셨겠지만 사실 <strong>프로토콜</strong>입니다.</p>\n<p>Swift에서 concurrent한 작업을 하기 위해서는 <strong>Sendable 프로토콜을 준수한 값</strong>들을 사용해야하는 것이죠..!</p>\n<p>자.. 다시 클로저로 돌아가봅시다.</p>\n<p><strong>클로저</strong>가 <strong>Sendable</strong>하려면 어떤 경우여야 할까요?</p>\n<p>간단합니다. 클로저가 <strong>캡처하는 모든 값들이 Sendable</strong>해야하죠.</p>\n<p>또 캡처한 값들이 **mutable(<code>var</code>)**하면 안됩니다.</p>\n<p>그러면 Data Race가 발생할테니까요..</p>\n<p>마지막으로 클로저가 <strong>synchronous</strong>한 경우에 actor에서 <strong>독립된 형태이면 안됩니다</strong>.</p>\n<p>외부에서 접근이 가능해지니까요!</p>\n<h3 id=\"Main-Actor\"><a href=\"#Main-Actor\" class=\"headerlink\" title=\"Main Actor\"></a>Main Actor</h3><p>마지막으로 살펴볼 게 있습니다.</p>\n<p><strong>Main Actor</strong>라는 특수한 actor인데요, 이미 전에 한 번 언급된 적이 있었죠?</p>\n<p>백그라운드에서 작업을 하다가 다시 메인쓰레드로 넘어와 UI를 업데이트해야 하는 상황..</p>\n<p>아주 익숙하죠?</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">DispatchQueue.main.async &#123;\n  updateButton()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>보통 위와 같이 **<code>DispatchQueue.main</code>**을 사용해오곤 했습니다.</p>\n<p><img src=\"https://i.imgur.com/CcWieeY.png\"></p>\n<p>**<code>@MainActor</code>**는 해당 작업이 <strong>메인쓰레드</strong>에서 이루어져야 한다는 것을 명시하는 키워드입니다.</p>\n<p><code>DispatchQueue.main</code> 대신 사용하여 명시적으로 메인쓰레드에서 동작해야한다는 것을 컴파일러에게 알려줍시다..!</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>참고 문서</p></blockquote>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2021/10254/\">WWDC21 - Swift concurrency: Behind the Scenes</a></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2021/10134/\">WWDC21 - Explore structured concurrency in Swift</a></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2021/10133/\">WWDC21 - Protect mutable state with Swift actors</a></p>\n<p><a href=\"https://sujinnaljin.medium.com/swift-async-await-concurrency-bd7bcf34e26f\">naljin - Swift async &#x2F; await &amp; concurrency</a></p>\n","feature":true,"text":"ConcurrencyWWDC21의 주요 주제는 Concurrency라고 생각합니다. 21년에 처음 공개된 후 관련된 포스트도 많아졌고 서드파티 라이브러리에서도 대응 업데이트가 많이 이루어진 상황입니다. 이제 슬슬 실무에 사용되는 모습들도 보이기 시작하...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Concurrency\"><span class=\"toc-text\">Concurrency</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\"><span class=\"toc-text\">비동기 프로그래밍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GCD%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90\"><span class=\"toc-text\">GCD의 진짜 문제점</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-x2F-await\"><span class=\"toc-text\">async &#x2F; await</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async\"><span class=\"toc-text\">async</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#await\"><span class=\"toc-text\">await</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Suspend\"><span class=\"toc-text\">Suspend</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Task\"><span class=\"toc-text\">Task</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Task-Tree\"><span class=\"toc-text\">Task Tree</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Structured-Tasks\"><span class=\"toc-text\">Structured Tasks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#async-let-Tasks\"><span class=\"toc-text\">async-let Tasks</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Group-Tasks\"><span class=\"toc-text\">Group Tasks</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Unstructured-Tasks\"><span class=\"toc-text\">Unstructured Tasks</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Detached-Tasks\"><span class=\"toc-text\">Detached Tasks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%A0%95%EB%A6%AC\"><span class=\"toc-text\">정리</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Actor\"><span class=\"toc-text\">Actor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Actor-Reentrancy\"><span class=\"toc-text\">Actor Reentrancy</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Actor-Isolation\"><span class=\"toc-text\">Actor Isolation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Protocol\"><span class=\"toc-text\">Protocol</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Closure\"><span class=\"toc-text\">Closure</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Main-Actor\"><span class=\"toc-text\">Main Actor</span></a></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"29)🍎 Swift - 인스타그램 스토리로 공유하기","uid":"96468e592e7cdf6f399481c66d5c9acd","slug":"Swift/2023-05-30-Swift29","date":"2023-05-06T15:00:00.000Z","updated":"2023-06-07T08:34:40.943Z","comments":true,"path":"api/articles/Swift/2023-05-30-Swift29.json","keywords":null,"cover":"https://i.imgur.com/YnrGnKE.png","text":"인스타그램 스토리 공유오늘은 앱에서 얻어낸 사진을 인스타그램 스토리로 공유하는 법을 공부해보겠습니다. Instagram - Sharing to stories 해당 문서를 따라가며 진행해보죠! 앱 ID 휙득하기 가장 먼저 눈에 띄는 경고문이 있네요! 다...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"25)🍎 Swift - Package","uid":"06d14767cdd4b129532d498df40afc71","slug":"Swift/2023-03-10-Swift25","date":"2023-03-09T15:00:00.000Z","updated":"2023-06-07T08:34:26.852Z","comments":true,"path":"api/articles/Swift/2023-03-10-Swift25.json","keywords":null,"cover":"https://i.imgur.com/nheVjo5.png","text":"Package (패키지) 패키지란 프로젝트 내에서 사용하는 코드&#x2F;리소스들을 재사용하기 쉽도록 묶어 정돈하거나 다른 개발자나 커뮤니티와 공유하기 위한 기능입니다. Xcode는 이런 패키지 기능을 Swift Package Manager를 통해 쉽...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}